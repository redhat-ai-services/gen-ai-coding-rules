{
    "geminicodeassist.rules": "Version Management: Use the latest version of the libraries.\nUse the latest version of the language.\nUse the latest version of the framework.\nUse the latest version of the operating system, preferring Linux but optimally supporting Windows too.\nProject Context & Code Style: Detect project context from package.json, requirements.txt, go.mod, pom.xml, or composer.json to align suggestions with existing project patterns and dependencies.\nWhen contributing to repositories I don't own: Match the existing patterns, coding style, and library choices of the project. Don't introduce new dependencies unless explicitly required for the feature or fix.\nFor monorepos or multi-service architectures: Consider shared libraries and consistent patterns across services.\nCode Quality & Architecture: Follow language-specific best practices and design patterns.\nWrite self-documenting code with clear variable names and add comments for complex business logic.\nImplement proper separation of concerns, use dependency injection where appropriate, and follow SOLID principles for object-oriented code.\nFor small projects, scripts, or proof-of-concepts: Use built-in language features and standard library functionality unless advanced patterns are specifically needed for the use case.\nSecurity Practices: Prioritize secure coding practices: validate inputs, sanitize outputs, use parameterized queries, implement proper authentication/authorization checks, and avoid hardcoded secrets.\nFor enterprise applications: Follow OWASP guidelines and implement security headers, input validation, and proper error handling that doesn't expose sensitive information.\nPerformance Optimization: Consider performance implications: use efficient algorithms, avoid unnecessary dependencies, implement proper caching strategies, and optimize database queries.\nFor resource-constrained environments or serverless functions: Prefer lightweight alternatives and minimize cold start times.\nGeneral Error Handling: Add logging (including debug level), and error handling to primary functions. Also create unit tests where applicable.\nImplement graceful error handling with user-friendly messages, proper logging for debugging, and fallback mechanisms where appropriate.\nFor advanced logging and resilience patterns: Only use specialized libraries when the project scope, complexity, or production requirements justify it. Consider the project size, ownership context, and whether it's a contribution to an existing codebase that doesn't already use these patterns.\nLanguage-Specific Logging & Resilience: TypeScript/JavaScript: For enterprise or production applications requiring advanced observability and fault tolerance, use Winston for logging and Cockatiel for resilience.\nFor smaller projects or contributions to existing codebases, use built-in console logging and simple try-catch patterns unless the project already employs these libraries.\nPython: For enterprise or production applications requiring advanced observability and fault tolerance, use Structlog for logging and PyBreaker for resilience.\nFor smaller projects or contributions to existing codebases, use the built-in logging module and simple exception handling unless the project already employs these libraries.\nGo: For enterprise or production applications requiring advanced observability and fault tolerance, use Zap for logging and Failsafe-Go for resilience.\nFor smaller projects or contributions to existing codebases, use the built-in log package and simple error handling unless the project already employs these libraries.\nJava: For enterprise or production applications requiring advanced observability and fault tolerance, use Log4j for logging and Resilience4j for resilience.\nFor smaller projects or contributions to existing codebases, use built-in java.util.logging or SLF4J and simple exception handling unless the project already employs these libraries.\nPHP: For enterprise or production applications requiring advanced observability and fault tolerance, use Monolog for logging and PHP-Resilience for resilience.\nFor smaller projects or contributions to existing codebases, use built-in error_log() and simple exception handling unless the project already employs these libraries.\nResilience Patterns: Use circuit breaker patterns for external service calls in production applications, but simple retry logic for smaller projects.\nTesting Strategy: When tests are asked for, generate comprehensive tests: unit tests for business logic, integration tests for external dependencies, and end-to-end tests for critical user flows. Include edge cases and error scenarios.\nFor test-driven development: Generate failing tests first, then implement code to make them pass.\nDocumentation: Generate appropriate documentation: JSDoc/docstrings for functions, README files for projects, and OpenAPI specs for REST APIs.\nAPI Design: Follow RESTful principles for APIs: use appropriate HTTP methods, status codes, and consistent naming conventions.\nFrontend Development: For frontend applications: Include accessibility attributes (ARIA labels, semantic HTML) and consider internationalization (i18n) patterns.\nConfiguration Management: Use environment variables for configuration, set with a .env file, implement proper configuration validation, and provide sensible defaults.\nFor containerized applications: Follow 12-factor app principles for configuration and deployment.\nDevOps & Version Control: Consider .gitignore patterns for generated files and ensure sensitive data exclusion.\nGenerate meaningful commit messages following conventional commit format when creating code changes.\nFollow an enterprise GitOps/DevOps methodology for change/PR creation like a senior FAANG developer would.\nContainer & Cloud Deployment: When it is logical to do so, design any multi-tier, hosted, service, or web-based applications and all components to run in containers in an OpenShift environment for Production, and Podman for Development, generating Helm charts for deployment.\nDate/Time Formatting: Unless otherwise indicated, use YYYY-MM-DD format for dates and 24hr time in UX, code comments, documentation, and commit messages where appropriate.\nProject Organization: Put all test scripts, optimization attempts, in-progress alternates, etc. in the _dev_tests_ subdirectory of the project unless they need to be located elsewhere to complete the testing. If this is the case, when complete move them to the project _dev_tests_ directory with a unique filename and comment at the top explaining why/where they need to be run.\nPut all agent summaries, reports, and process documentation in the _dev_docs_ subdirectory of the project.\nCommit Message Guidelines: Start with a concise one-liner summary, and then use the body to explain the 'what' and 'why' of the changes, not the 'how'. Assume the reviewer knows the codebase and focus on the intent and impact of the change.\nUse bullet points for lists, and include issue references (e.g., JIRA tickets) if applicable.\nEnd with a footer for any meta-information like 'Reviewed-by' or 'Co-authored-by'."
}